# 方案内效率测试
## 1. 非优化版证明及验证

  prove_base()
  verify_base()

## 2. 优化版证明及验证

  prove_improved()
  verify_improved()

## 3. 测试

  - 理论分析
    
    - 验证 pointproof 部分, delta 计算时间跟总比特数线性
    - 验证 ipa 部分, base 版本时间跟总比特数线性, improved 版本时间跟总比特数对数

    - [验证时间可细分]为 pointproof(line 26-27), ipa(line 28-31) 和 total(两者之和)
    - [证明时间也可对应细分]为 3 个部分
    - 其他参数: [证明大小], [承诺大小]

  - 我们的优点

    - 使用线性代价实现了值在集合里的证明. /** compute sum_z_pows_cdot_dj **/ 的计算可以优化, 从 D|I| 优化为 D
    - improved 版本实现了对 verifier 友好的 ipa
    - 多值范围证明时, 由于只提交一个群元素, 因此在值很多时, 可以极大减少[承诺大小]\( 其他多值范围证明有对应的优化吗 )

  - 理论上支持 256-bit 数字, 但实际上可能并不需要使用这么多比特（不需要这么大的范围）:
    使用 [2, 8, 16, ..., 128, 256] 比特（小范围->大范围）

    - 固定数字集合总比特: [数字比特]变大, [集合大小]对应变小 -> [总比特]不变(2^10 ~ 2^20, try 2^24?)

      会不会花费时间只跟总比特有关
      2^10 单次证明验证约10秒, 2^20 约3个小时
  
    - 固定数字集合大小: 集合大小变化, 数字比特不变 -> 总比特变化(2^10 ~ 2^24)

  - base 版本与 improve 版本, 需要[总比特变化], 才能体现出 improve 版本的优势

    base 版本: point_proof 线性验证
    improve 版本对数验证

  - 与其他方案的对比

    bulletproof-base: 多次的
    

## 4. 现有问题

  - [] ipa 验证时需要执行 log N 次随机数生成, 耗时占总验证用时的 60% 左右(Debug 版本)
  - [√] /** compute sum_z_pows_cdot_dj **/ 的计算可以优化, 从 D|I| 优化为 D

    有改进

  - [×] poly_fh 可优化, 减少 N 次, 需要 [beta^(N+2)]_2

    [h]_1 需要用于 ipa_verify, 减少 N 次意味着计算 [h_apos]_1 =  [beta^(-N) * h]_1, 但验证者没法通过 [h_apos]_1 恢复 [h]_1. 
    
    验证者仅能恢复出 [h]_T. 因为恢复过程需要做指数上的乘法, 这只能用配对实现, 配对的结果不再是 G1 群元素.

  - [×] 要不把 F 也拆成两个多项式进行承诺然后证明?

    由上一条只这一条不行

  - 安全位数: 椭圆曲线位数和安全等级的关系
    我们的系统包含椭圆曲线 G 和域 F, 因此安全等级取两者低值
      群: S(G) = c + |G|/2, 160-bit 的群提供 80-bit 安全(0 <= c <= 10, 群运算比对称密码系统的基本应用慢2^c倍)
      域: S(F) = \tau + S(|F|_RSA). 1024-bit有限域提供76-bit安全, 2048-bit有限域提供106-bit安全
      
    我们的系统使用 bn128, bn128 只提供110-bit安全: https://electriccoin.co/blog/new-snark-curve/